# 第十一章 复制

MongoDB复制是将数据库内容同步复制到多个服务器。

## MongoDB复制集的目标

复制用于实现可伸缩性，持久性/可靠性和隔离性。

### 提升可伸缩性

复制通过两个方面提升可伸缩性：

+ 提高冗余度：复制可以使客户在多个数据中心托管应用程序，从而帮助提高冗余度。使用这种方法，可以确保在每一个数据中心都有一个数据的本地副本，所以应用程序可以进行高速访问，客户因此可以连接距离最近数据中心，最大程度减少延迟。
+ 提升性能

### 提升持久性/可靠性

复制通常用于防止硬件故障或数据库崩溃，当执行备份或其他有较大影响的维护性活动时有很强的灵活性，因为这些活动可以在单个数据集上进行而不影响整个数据集。

使用复制功能的几种情况：

+ 当想有一个可以延迟运行的数据库的副本时
+ 当想在发生故障时有一个备份系统时：将数据库副本作为备份数据库运行，以防在系统发生故障时，普通的备份模式可以能需要花费太多时间来恢复数据库
+ 当出于管理目的想要一个冗余系统：运行副本，可以在节点之间轮换执行备份或升级这类管理任务。

### 支持隔离性

如果在生产数据库中运行某些过程，则会严重影响该数据库的性能或可用性。可以使用复制功能来创建 将生产数据库与某些进程隔离的同步副本。

+ 特别是当想要在不影响生产数据库性能的前提下执行报告或备份

## 复制集简介

MongoDB复制集是一种 设置多个MongoDB实例来 实现冗余和其他相关目标的 包含相同数据的方法。

+ 完成复制的方法（这些方法都已被复制集取代）：

1. 主/从复制Master/Slave Replication 

2. 主/主复制Master/Master Replication 

3. 复制对Replica Pairs 

MongoDB中，复制集由一个primary（主）节点和多个secondary（辅助）、arbiter（选举）节点组成。最小成员数为3，且建议复制集成员数量都是奇数（通常相近的奇偶数容忍的失效节点数是一样的）。

复制集最多可以有50个非投票成员和7个投票成员组成。

*最主要的规则是避免出现“脑裂”问题*

### primary节点

+ primary节点是副本集在给定时刻的真实来源，是数据集中能够将数据通过应用程序直接写入数据集中的唯一节点，所有其他的节点最终都可以通过这个节点复制数据。

+ primary节点是由投票成员的大多数（假设复制集内投票成员数为N，大多数为N/2-1）投票同意得出来的（quorum），其余节点就成为secondary节点。当复制集内存活成员数不足大多数时，整个复制集将无法选举出primary节点，复制集将无法提供写服务，处于只读状态。

+ 当唯一的主节点发生宕机时会从从节点的Priority参数不为0当中选举一个为主节点，所以说主是唯一的，但不是固定的。
+ 主节点可以读写。

### secondary（辅助）节点

+ 正常情况下，secondary节点会参与primary节点选举（自身也可能被选为primary节点），并从primary同步最新写入的数据，以保证与primary存储相同的数据。

+ Secondary节点只提供read读服务，增加Secondary节点可以提供复制集的读服务能力，同时提升复制集的可用性。另外，Mongodb支持对复制集的Secondary节点进行灵活的配置，以适应多种场景的需求。

### arbiter（选举）节点

+ arbiter节点是非数据承载节点，不能被选为primary节点，并且不从primary节点同步数据。

如果副本集中有偶数个投票成员，则arbiter节点可以提供额外的投票选出primary节点，但是它不进行决定性投票，不直接决定哪个是primary，只是复制集成员（投票成员）。

*arbiter节点可以避免脑裂问题*

## Oplog（operation log）——复制集的纽带

操作日志（Oplog）是一个固定（capped）集合，secondary节点查询primary节点的Oplog来进行复制。

每个节点都有自己的Oplog，记录从primary节点复制过来的信息，这样每个成员都可以作为同步源给其他节点提供信息。

+ 副本集数据同步的过程：

  Primary节点写入数据，Secondary节点通过读取Primary节点Oplog得到复制信息，开始复制数据并且将复制信息写入到自己的Oplog。如果某个操作失败（只有当同步源的数据损坏或者数据与主节点不一致时才可能发生），则secondary节点停止从当前数据源复制数据。如果某个secondary节点由于某些原因挂掉了，当重新启动后，就会自动从Oplog的最后一个操作开始同步，同步完成后，将信息写入自己的Oplog。

  将Oplog的同一个操作执行多次，与执行一次的效果是一样的。

+ 通常Oplog使用空间的增长速度跟系统处理写请求的速度相当。

  如果主节点上每分钟处理1KB的写入数据，那么Oplog每分钟大约也写入1KB数据。

  如果尚未在当前实例上创建Oplog，可以使用`--oplogSize`命令行选项来为Oplog设置大小（以megabytes兆字节为单位）。默认设置为可用磁盘空间的5%（最小1GB，最大50GB）

  使用`db.printReplicationInfo() `函数，查看最适合Oplog的大小以及Oplog的其他信息。从中可以估计是否需要增加或减小Oplog的大小。

## 建立复制集

### 创建一个复制集

例如，建立一个复制集testset，其中有两个投票成员和一个非投票成员

配置三个成员的host地址，dbpath路径:

```
Service         Daemon Address        Dbpath
Voting Member 1 mongod [hostname]:27021 /db/active1/data
Voting Member 2 mongod [hostname]:27022 /db/active2/data 
Nonvoting Member 1 mongod [hostname]:27023 /db/passive1/data
```

当所有机器都位于一个服务器上时，复制集才允许将localhost作为identifier，因此最好使用[hostname]。复制集的每个成员必须可以通过[hostname]去连接其他的MongoDB实例。

在命令行窗口输入`hostname`得出当前的[hostname]，之后，得出的结果例如"LAPTOP-VK1QSLEK"替代配置中的[hostname]

### 准备好复制集成员后运行

在命令行窗口中

```
mkdir -p db\active1\data//使用mkdir创建文件路径
mongod --dbpath db\active1\data --port 27021 --replSet testset//创建名为testset的复制集 ，这是复制集的第一个成员，所有子成员都需要以这个名字为开头
```

另外打开另外两个命令行窗口，配置其他复制集成员

```
mkdir -p db\active2\data
mongod --dbpath db\active2\data --port 27022  --replSet testset
```

```
mkdir -p db\passive1\data
mongod --dbpath db\passive1\data --port 27023 --replSet testset
```

但此时并没有将复制集配置完毕，因为还没有初始化副本集并向每个成员指示其角色和职责。

第一台服务器将成为新复制集的初始主服务器

```
mongo [hostname]:27021//选择一个服务器连接
>rs.initiate()//执行初始化命令
>rs.status()//检查复制集的状态查看其是否成功建立了
```

















































